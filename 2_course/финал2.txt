Anton Volkov
Вопрос по финалу второго курса.
shared_ptr<Node> condition = ParseCondition(is);
      auto predicate = [condition](const Date& date, const string& event) {
        return condition->Evaluate(date, event);
      };
      int count = db.RemoveIf(predicate);
Я правильно понимаю что параметры predicate указываются уже в описании метода db.RemoveIf ?
И этот метод должен принемать шаблонную функцию?

Nikita Kuznetsov
Anton Volkov
И этот метод должен принемать шаблонную функцию?
Ага, ну либо std::function

Anton Volkov
Спасибо, Никита. Теперь бы еще понять что из себя должна представлять Evaluate и зачем в нее передавать date и event

Nikita Kuznetsov
Anton Volkov
Спасибо, Никита. Теперь бы еще понять что из себя должна представлять Evaluate и зачем в нее передавать date и event
Evaluate должна возвращать результат логического выражения
Удовлетворяет дата и событие заданному условию или нет

Anton Volkov
Т.е. мы просто перербором передаем в Evaluate записи базы данных. А она говорит подходит или нет?

Nikita Kuznetsov
Почему перебором

Anton Volkov
Ну мы же не знает в RemoveIf какие date + event передавать в нее. Передаем их по очереди, нет?

Nikita Kuznetsov
Как это не знаем
Обращение к бд же с условием )

Anton Volkov
не очень понимаю. 
Мы вызвываем db.FindIf(predicate).
В predicate вызываем condition->Evaluate(date, event).
которая проверяет подходят ли date, event под условия.
Но откуда мы знаем какие date, event подсовывать? Мы же всю базу должны проверить

Nikita Kuznetsov
А, ну дальше уже да
Приходит то по сути тру или фолс в метод

Anton Volkov
вот я и говорю что получается в в методе RemoveIf мы циклично проверяем записи с помощью вызова predicate(date, event).

Nikita Kuznetsov
Получается что так )

Anton Volkov
ну слава богу. А ты вы меня напугали. Толлько подумал что что то в голове сформировалось))

Nikita Kuznetsov
Там, по моему, даже в подсказке написано было, что эти операции требуют прохода по всей базе )

Anton Volkov
аа.. надо перечитать еще раз.